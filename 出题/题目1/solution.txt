这道题有两种做法。各有各的优点。

第一种做法是有一个结论，最优的这条链一定在树的直径上。并且为了最优，我们一定可以让这条链尽量长度刚好等于C，如果直径的长度小于C那么就让这条链刚好等于直径就可以了。然后知道肯定是直径上的连续一段的话，我们就可以用递推，每次枚举直径上连续的长度为C的一段，计算代价。这个代价是可以预处理出来的，一次dp就好。

第二种做法是dp。f[i][j]表示以i为链的上端，长度不超过j的最小距离和。那么有两种转移，一种是f[i][j] = f[son][j - 1] + cost，一种是合并两个子树的链即f[i][j] = f[son1][k] + f[son2][j - k] + cost。对于第二种转移需要优化，优化方法见09年徐持衡国家集训队论文。虽然说得很玄乎但是这个dp还是很好写的，细节考虑考虑清楚的话代码不长。转移的优化也比较容易想到。不过还是比上面那种方法要繁琐了一点。
