首先这个图肯定是棵树。我们先任意指定一个点当根。然后再来看每次路径对应的起点和终点。
假设现在已经变成了一棵有根树，并且起点为A，终点为B。
设A与B的最近公共祖先为C，那么问题转化成子问题A->C,C->B和在A~C的路径上买在C~B的路径上卖。
所以我们对于每个点维护它到祖先的路径上的最大值，到祖先路径上的最小值。以及从它到祖先路上可以得到的最优解，和从祖先到它路上可以得到的最优解。
不论是用倍增算法还是并查集的LCA，都是可以维护的。
以上。
